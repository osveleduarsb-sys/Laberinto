<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" 
content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Laberinto con sapito</title>
<link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@600&display=swap" rel="stylesheet">
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;        /*  sin scroll */
  touch-action: none;      /*  sin gestos */
  overscroll-behavior: none;
  background: black;
}
</style>
<style>
  body {
    margin: 0;
    background: #111;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
  }

  canvas {
    background: #111;
    touch-action: none;
    margin-bottom: 20px;
  }

  .controls {
    display: grid;
    grid-template-columns: 50px 50px 50px;
    gap: 10px;
  }
  .controls button {
    width: 50px;
    height: 50px;
    font-size: 20px;
    cursor: pointer;
    border: 2px solid #fff;
    border-radius: 5px;
    background: #222;
    color: #fff;
  }
  .controls .up { grid-column: 2; }
  .controls .left { grid-column: 1; }
  .controls .down { grid-column: 2; }
  .controls .right { grid-column: 3; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div class="controls">
  <button class="up">‚Üë</button>
  <button class="left">‚Üê</button>
  <button class="down">‚Üì</button>
  <button class="right">‚Üí</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const dpr = window.devicePixelRatio || 1;

function handleSignClose(x, y) {
  if (!signDialogActive || !signBox) return;

  const inside =
    x >= signBox.x &&
    x <= signBox.x + signBox.w &&
    y >= signBox.y &&
    y <= signBox.y + signBox.h;

  // üëâ solo cerrar si toc√≥ FUERA
  if (!inside) {
    signDialogActive = false;
    signBox = null;
  }
}

canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  handleSignClose(x, y);
});

canvas.addEventListener("touchstart", e => {
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches[0];
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;
  handleSignClose(x, y);
});

canvas.addEventListener("click", () => {
  if (signDialogActive) {
    signDialogActive = false;
  }
});

canvas.addEventListener("touchstart", () => {
  if (signDialogActive) {
    signDialogActive = false;
  }
});

let signTouchStartY = 0;

// Tama√±o del canvas
const SIZE = Math.min(window.innerWidth, window.innerHeight) - 40;
canvas.style.width = SIZE + "px";
canvas.style.height = SIZE + "px";
canvas.width = SIZE * dpr;
canvas.height = SIZE * dpr;
ctx.scale(dpr, dpr);

// Maze
const maze = [
  [
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ],
  [
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1
  ],
  [
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1
  ],
  [
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ],
  [
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    0,
    0,
    0,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    0,
    0,
    0,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    0,
    0,
    0,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1
  ],
  [
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    1
  ],
  [
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    0,
    2,
    1,
    2,
    0,
    2,
    2,
    2,
    0,
    2,
    2
  ],
  [
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    1,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ],
  [
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2
  ],
  [
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ]
];

const ROWS = maze.length;
const COLS = maze[0].length;

let roach2Hit = false;
let vibrationUnlocked = false;
let roachActive = false;
let roachEaten = false;
let roachEating = false;
let roachEatProgress = 0;
let blockActive = false;
let mazeVisible = true;
let finalSequenceActive = false; // üíÄ solo true al final final
let mazeBlinking = false;
// ü™ß Estado visual de carteles
let signsVisible = true;
let signsBlinking = false;
let signsBlinkInterval = null;
let mazeBlinkInterval = null;
let controlsInverted = false;
let signBreath = 0;
// ‚ù§Ô∏è‚Äçüî• Part√≠culas de da√±o
const damageParticles = [];
// ‚ú® Part√≠culas del sapito
const particles = [];
// üå∏ Flores del pasillo m√°gico
const flowers = [];
// ü™≥ü™≥ CUCARACHAS CRUZADAS
let roachTop = { row: 8, col: 50, active: false, hit: false };
let roachBottom = { row: 26, col: 50, active: false, hit: false };
let roachDuelFinished = false;
// ü™≥ CUCARACHA PATRULLA
let roachPatrol = {
row: 32,
col: 46,
dir: -1,          // -1 izquierda, 1 derecha
active: false,
finished: false,
hit: false
};
// ü™≥ CUCARACHA VERTICAL (ataque sorpresa)
let roachDrop = {
row: 36,
col: 34,
active: false,
finished: false,
hit: false
};
let roachDuelTriggered = false; // üõë esta zona solo puede activarse una vez
let gameOver = false;
let messageSoundLocked = false;

const roachDropStartRow = 36;
const roachDropEndRow = 42;

const patrolLeftLimit = 34;
const patrolRightLimit = 46;

// üìç Zona de flores
const flowerZone = {
row: 28,
colStart: 30,
colEnd: 42
};
// ü™ß CARTELES (solo visual por ahora)
const signPosts = [
  { row: 13, col: 26 },
  { row: 24, col: 46 },
  { row: 41, col: 46 },
];
//  Checkpoint actual
let lastCheckpoint = null;
// üíö Vidas (FASE 1 solo visual)
let lives = 3;
const MAX_LIVES = 3;
// Nueva cucaracha vengadora
const roach2 = {
row: 2,
col: 22,
active: false,
finished: false
};
let blinkingHeartIndex = -1; // qu√© coraz√≥n parpadea
let heartBlinkCount = 0;
let heartBlinkInterval = null;

const roach2StartCol = 22;
const roach2EndCol = 38;

// ‚ú® Parpadeo del mensaje
let messageBlinking = false;
let messageBlinkCount = 0;
let messageBlinkInterval = null;
let messageAlpha = 1;

let currentMessage = "Ayuda al sapito a llegar a la princesa";

// Variables para la escena especial
let princessBlinking = false;
let princessBlinkCount = 0;
let princessBlinkInterval = null;
let princessVisible = true;
let specialMessage = "";
let specialMessageIndex = 0;
let specialMessageInterval = null;
let specialSceneActive = false;
// üé¨ ESCENA FINAL TIPO CR√âDITOS
let endingActive = false;
let endingMessage = "";
let endingMessageIndex = 0;
let endingMessageInterval = null;
let endingPhase = 0; // 0 = escribiendo, 1 = esperando, 2 = mostrar FIN
let endingFinalTimer = null;
let finalBlinking = false;
let finalBlinkInterval = null;
let finalBlinkVisible = true;
let endingTextAlpha = 0; // opacidad del texto final (0 ‚Üí 1)
let endingFadeInterval = null;
let musicStarted = false;

function startMusic() {
if (musicStarted) return;

bgMusic.play().catch(() => {});
musicStarted = true;
}

function stopMusic() {
  if (!musicStarted) return;

  bgMusic.pause();
  bgMusic.currentTime = 0;
  musicStarted = false;
}

// Funci√≥n que inicia la escena especial al llegar a (50, 48)
function checkSpecialPrincessZone() {
if (player.row === 50 && player.col === 48 && !specialSceneActive) {
specialSceneActive = true;

// asegurar que el sapito quede clavado ah√≠
player.moving = false;
player.x = PADDING_X + player.col * CELL + CELL / 2;
player.y = PADDING_Y + player.row * CELL + CELL / 2;
player.targetX = player.x;
player.targetY = player.y;

currentMessage = "üíö ‚Ä¶";
vibrate(100);

// iniciar parpadeo de la princesa

princessBlinking = true;
princessBlinkCount = 0;
princessVisible = true;

// üîä SONIDO EMPIEZA CUANDO COMIENZA EL PARPADEO
soundPrincessGone.currentTime = 0;
soundPrincessGone.play().catch(() => {});

princessBlinkInterval = setInterval(() => {
princessVisible = !princessVisible;
princessBlinkCount++;

if (princessBlinkCount >= 6) {
clearInterval(princessBlinkInterval);
princessBlinking = false;
princessVisible = false;
startSpecialMessage();
}
}, 250);

}
}

// Funci√≥n para mostrar mensaje letra por letra
function startSpecialMessage() {
specialMessage = "oh no... Las cucarachas capturaron a la princesa";
specialMessageIndex = 0;
currentMessage = "";

//  detener mÔøΩsica de fondo al iniciar el mensaje dramÔøΩtico
  stopMusic();

specialMessageInterval = setInterval(() => {
if (specialMessageIndex < specialMessage.length) {
currentMessage += specialMessage[specialMessageIndex];
specialMessageIndex++;
} else {
clearInterval(specialMessageInterval);

// ‚è≥ esperar 2 segundos y activar final
setTimeout(() => {

finalSequenceActive = true;

mazeVisible = false;

// üí• PARPADEO TOTAL (laberinto + sapito + corazones)
blinkFinalScene(10, 120);
blinkSigns(10, 120);

setTimeout(() => {
endingActive = true;
document.querySelector(".controls").style.display = "none";

fadeInEndingText(); // ‚ú® aparecer suavemente
startEndingMessage();
}, 1300);

}, 2000);
}
}, 60);
}

function startEndingMessage() {
endingMessage =
"Aunque no lograste el objetivo esta vez... nunca te rindas, cuando lo intentas est√°s a un paso m√°s de lograrlo.";

endingMessageIndex = 0;
currentMessage = "";

//  sonido al iniciar texto final
  soundEndingStart.currentTime = 0;
  soundEndingStart.play().catch(() => {});

endingMessageInterval = setInterval(() => {
if (endingMessageIndex < endingMessage.length) {
currentMessage += endingMessage[endingMessageIndex];
endingMessageIndex++;
} else {
clearInterval(endingMessageInterval);

// ‚è≥ esperar 3 segundos antes del FIN
endingPhase = 1;

endingFinalTimer = setTimeout(() => {
endingPhase = 2;
}, 3000);

}
}, 85); // m√°s r√°pido que el anterior
}

function fadeInEndingText(duration = 800) {
endingTextAlpha = 0;

const steps = 20;
const stepTime = duration / steps;
let currentStep = 0;

if (endingFadeInterval) clearInterval(endingFadeInterval);

endingFadeInterval = setInterval(() => {
currentStep++;
endingTextAlpha = currentStep / steps;

if (currentStep >= steps) {
endingTextAlpha = 1;
clearInterval(endingFadeInterval);
}

}, stepTime);
}

// Dibujar princesa con parpadeo
function drawPrincess() {
if (!princessReady) return;
if (!princessVisible) return;

const size = CELL * 9;
const col = COLS - 0;
const row = ROWS - 3;

const x = PADDING_X + col * CELL + CELL / 2;
const y = PADDING_Y + row * CELL + CELL / 2;

ctx.drawImage(
princessImg,
x - size / 2,
y - size / 2,
size,
size
);
}

function vibrate(pattern) {
if (!vibrationUnlocked) return;
if (navigator.vibrate) {
navigator.vibrate(pattern);
}
}

function lockMessageSound(duration = 500) {
messageSoundLocked = true;
setTimeout(() => {
messageSoundLocked = false;
}, duration);
}

// Configuraci√≥n
const TITLE_HEIGHT = 70;
const MESSAGE_BOX_WIDTH = SIZE - 160; // ancho fijo del √°rea del texto
const TITLE_OFFSET_Y = -5; // ‚¨ÜÔ∏è sube el texto (aj√∫stalo)
const MESSAGE_OFFSET_Y = -22; // ‚¨ÜÔ∏è sube SOLO el texto (prueba -12, -18, -24)
const LABYRINTH_OFFSET_Y = -20; // ‚¨ÜÔ∏è sube el laberinto (ajusta este valor)
const PADDING = 10;
const LABYRINTH_HEIGHT = SIZE - PADDING * 2 - TITLE_HEIGHT; // espacio real para el laberinto
const CELL = LABYRINTH_HEIGHT / ROWS; // recalcular tama√±o de cada celda
const FLOWER_MIN_DISTANCE = CELL * 1.2; // separaci√≥n m√≠nima entre flores
const LABYRINTH_WIDTH = CELL * COLS;
const PADDING_X = (canvas.width - LABYRINTH_WIDTH) / 9;
const PADDING_Y = PADDING + TITLE_HEIGHT + LABYRINTH_OFFSET_Y;
// üéØ Centro horizontal del laberinto
const MAZE_CENTER_X = PADDING_X + LABYRINTH_WIDTH / 2;

const messagesByZone = [
{
row: 5,
col: 4,
text: "Para continuar deber√°s comer una cucaracha"
},
{
row: 9,
col: 10,
text: "se que muchas veces no estoy presente"
},
{
row: 2,
col: 18,
text: "pero pienso en ti m√°s de lo que t√∫ te imaginas"
},
{
row: 10,
col: 38,
text: "Avanza siempre aunque no veas el camino"
},
{
row: 24,
col: 38,
text: "¬°lo lograste! siempre encontrar√°s el camino de vuelta"
},
{
row: 28,
col: 30,
text: "Estoy s√∫per orgulloso de ti ojitos"
},
{
row: 17,
col: 42,
text: "te quiero mucho"
},
{
row: 17,
col: 50,
text: "ups"
},
{
row: 42,
col: 34,
text: "Falta poco, est√°s muy cerca"
}
];

const roach = {
row: 21,
col: 14
};

// Jugador
// Jugador (entrada real del laberinto)
let player = {
row: 2,
col: 0,
x: 0,
y: 0,
targetX: 0,
targetY: 0,
moving: false
};

function checkGameOver() {
if (lives <= 0 && !gameOver) {
gameOver = true;

currentMessage = ""; // quitar mensajes normales
soundWin.currentTime = 0;
soundWin.play().catch(()=>{});

// detener enemigos
roach2.active = false;
roachTop.active = false;
roachBottom.active = false;
roachPatrol.active = false;
roachDrop.active = false;

setTimeout(resetGame, 2000); // reinicia en 2 seg

}
}

function drawGameOver() {
if (!gameOver) return;

const text = "GAME OVER";
const scale = 3;
const width = getPixelTextWidth(text, scale);
const textHeight = 5 * scale;

// üü¢ CENTRAR RESPECTO AL LABERINTO (mantenerlo igual)
const x = PADDING_X + (LABYRINTH_WIDTH - width) / 2;
const y = PADDING_Y + (LABYRINTH_HEIGHT - textHeight) / 2;

// fondo semitransparente que cubre toda la pantalla
ctx.fillStyle = "rgba(0,0,0,0.85)";
ctx.fillRect(0, 0, canvas.width, canvas.height); // <-- cambiar a todo el canvas

drawPixelText(text, x, y, scale, "#ff3c3c");
}

function drawEndingScene() {
if (!endingActive) return;

ctx.fillStyle = "black";
ctx.fillRect(0, 0, canvas.width, canvas.height);

const scale = 1.3;
const maxWidth = LABYRINTH_WIDTH * 0.9;

// üìù MENSAJE PRINCIPAL
const lines = wrapPixelText(currentMessage, maxWidth, scale);

let y =
PADDING_Y + LABYRINTH_HEIGHT / 2 -
(lines.length * 10 * scale) / 2
- 45; // üëà negativo = SUBE

ctx.save();
ctx.globalAlpha = endingTextAlpha;

for (let line of lines) {
const lineWidth = getPixelTextWidth(line, scale);
const x = PADDING_X + (LABYRINTH_WIDTH - lineWidth) / 2;
drawPixelText(line, x, y, scale, "#3cff3c");
y += 12 * scale;
}

ctx.restore();

// üèÅ FASE FINAL ‚Äî MOSTRAR "FIN DEL JUEGO"
if (endingPhase === 2) {
const scale2 = 2.2;
const text1 = "FIN DEL JUEGO";
const text2 = "ESPERA EL SIGUIENTE NIVEL";

const yBase = PADDING_Y + LABYRINTH_HEIGHT * 0.62; // ‚¨ÜÔ∏è sube FIN DEL JUEGO

const w1 = getPixelTextWidth(text1, scale2);
const x1 = PADDING_X + (LABYRINTH_WIDTH - w1) / 2;

const w2 = getPixelTextWidth(text2, 1.4);
const x2 = PADDING_X + (LABYRINTH_WIDTH - w2) / 2;

ctx.save();

ctx.globalAlpha = endingTextAlpha;

drawPixelText(text1, x1, yBase, scale2, "#ffffff");
drawPixelText(text2, x2, yBase + 28, 1.4, "#3cff3c");

ctx.restore();
}
}

function resetGame() {
// ‚ù§Ô∏è Vidas
lives = MAX_LIVES;
gameOver = false;

// üê∏ Jugador (respawn)
if (lastCheckpoint) {
  player.row = lastCheckpoint.row;
  player.col = lastCheckpoint.col;
} else {
  player.row = 2;
  player.col = 0;
}
player.moving = false;
updatePlayerPixels();

// üí¨ Mensajes
currentMessage = "Ayuda al sapito a llegar a la princesa";
messageAlpha = 1;
messageBlinking = false;

// üîÑ Estados globales
controlsInverted = false;
mazeBlinking = false;
blockActive = false;
vibrationUnlocked = false;

// üëª Restaurar estado del laberinto seg√∫n checkpoint
if (lastCheckpoint &&
    lastCheckpoint.row === 13 &&
    lastCheckpoint.col === 26) {

  mazeVisible = false;
  signsVisible = false;

} else {
  mazeVisible = true;
  signsVisible = true;
}

// ü™≥ MISI√ìN PRINCIPAL
roachActive = false;
roachEaten = false;
roachEating = false;
roachEatProgress = 0;

// ü™≥ Cucaracha vengadora
roach2.active = false;
roach2Hit = false;
roach2.finished = false;
roach2.col = roach2StartCol;
roach2.row = 2;

// ü™≥ Patrulla
roachPatrol.active = false;
roachPatrol.finished = false;
roachPatrol.hit = false;
roachPatrol.col = 46;
roachPatrol.dir = -1;

// ü™≥ Cucaracha ca√≠da
roachDrop.active = false;
roachDrop.finished = false;
roachDrop.hit = false;
roachDrop.row = roachDropStartRow;

// ü™≥ Duelo
roachTop.active = false;
roachBottom.active = false;
roachTop.hit = false;
roachBottom.hit = false;
roachDuelFinished = false;
roachDuelTriggered = false;
roachTop.row = 8;
roachBottom.row = 26;

// ‚ú® Efectos
damageParticles.length = 0;
particles.length = 0;
flowers.length = 0;

// üíö Corazones
blinkingHeartIndex = -1;
if (heartBlinkInterval) clearInterval(heartBlinkInterval);

// üß† Detener parpadeos activos
if (mazeBlinkInterval) clearInterval(mazeBlinkInterval);
if (messageBlinkInterval) clearInterval(messageBlinkInterval);
}

function drawRoach() {
if (!roachReady) return;
if (roachEaten) return; // si ya se comi√≥, no dibujes
if (!roachActive && !roachEating) return; // solo dibuja si est√° activa o se est√° comiendo

roachBreath += 0.04;
const breath = Math.sin(roachBreath) * 1.5;

let scale = 1;
let alpha = 0.95;

if (roachEating) {
roachEatProgress += 0.08;
scale = 1 - roachEatProgress;
alpha = 1 - roachEatProgress;

if (roachEatProgress >= 1) {
roachEating = false;
roachEaten = true;
roachActive = false;
roachEatProgress = 0;
return;
}

}

const baseSize = CELL * 4.5;
const size = (baseSize + breath) * scale;

const x = PADDING_X + roach.col * CELL + CELL / 2;
const y = PADDING_Y + roach.row * CELL + CELL / 2;

ctx.save();
ctx.globalAlpha = alpha;
ctx.drawImage(
roachImg,
x - size / 2,
y - size / 2,
size,
size
);
ctx.restore();
}

function drawSignPosts() {
if (!signReady) return;

signBreath += 0.05;
const breath = Math.sin(signBreath) * 1.2;

const baseSize = CELL * 2.5;

for (let s of signPosts) {

const isFixed = (s.row === 13 && s.col === 26);

if (finalSequenceActive) continue;
if (!mazeVisible && !isFixed) continue;
if (!isFixed && !signsVisible) continue;

const size = baseSize + breath;

const x = PADDING_X + s.col * CELL + CELL / 2;
const y = PADDING_Y + s.row * CELL + CELL / 2;

ctx.drawImage(
signImg,
x - size / 2,
y - size / 2,
size,
size
);

}
}

function drawRoach2() {
if (!roach2.active) return;

const size = CELL * 4.5;
const x = PADDING_X + roach2.col * CELL + CELL / 2;
const y = PADDING_Y + roach2.row * CELL + CELL / 2;

ctx.save();

// mover origen al centro
ctx.translate(x, y);

// rotar 90¬∞ a la derecha
ctx.rotate(Math.PI / 2);

ctx.drawImage(
roachImg,
-size / 2,
-size / 2,
size,
size
);

ctx.restore();
}

function drawRoachDuel() {
const size = CELL * 4.5;

[roachTop, roachBottom].forEach(r => {
if (!r.active) return;

const x = PADDING_X + r.col * CELL + CELL / 2;
const y = PADDING_Y + r.row * CELL + CELL / 2;

ctx.save();
ctx.translate(x, y);

// rotaci√≥n seg√∫n direcci√≥n
if (r === roachTop) ctx.rotate(Math.PI); // mirando hacia abajo
if (r === roachBottom) ctx.rotate(0);    // mirando hacia arriba

ctx.drawImage(roachImg, -size/2, -size/2, size, size);
ctx.restore();

});
}

function drawRoachPatrol() {
if (!roachPatrol.active) return;

const size = CELL * 4.5;
const x = PADDING_X + roachPatrol.col * CELL + CELL / 2;
const y = PADDING_Y + roachPatrol.row * CELL + CELL / 2;

ctx.save();
ctx.translate(x, y);

// ‚úÖ ROTACI√ìN CORRECTA
if (roachPatrol.dir === 1) ctx.rotate(Math.PI / 2);   // derecha
if (roachPatrol.dir === -1) ctx.rotate(-Math.PI / 2); // izquierda

ctx.drawImage(roachImg, -size/2, -size/2, size, size);
ctx.restore();
}

function drawRoachDrop() {
if (!roachDrop.active) return;

const size = CELL * 4.5;
const x = PADDING_X + roachDrop.col * CELL + CELL / 2;
const y = PADDING_Y + roachDrop.row * CELL + CELL / 2;

ctx.save();
ctx.translate(x, y);

// mirando hacia abajo
ctx.rotate(Math.PI);

ctx.drawImage(roachImg, -size/2, -size/2, size, size);
ctx.restore();
}

function updateRoach2() {
if (!roach2.active || roach2.finished) return;

// mover en l√≠nea recta hacia la derecha
if (roach2.col < roach2EndCol) {
roach2.col += 0.05; // ajusta velocidad, 0.15 es suave
} else {
// lleg√≥ al final ‚Üí desaparece
roach2.active = false;
roach2.finished = true;
return;
}

// colisi√≥n con sapito
if (
player.row === roach2.row &&
Math.round(player.col) === Math.round(roach2.col) &&
!roach2Hit
) {
roach2Hit = true;
lives--;

spawnDamageParticles(player.x, player.y);
checkGameOver();

lockMessageSound();

setMessage("¬°La cucaracha vengadora te mordi√≥! üíö", {
vibratePattern: [60, 40, 60]
});

soundEat.currentTime = 0;
soundEat.play().catch(() => {});

blinkHeart(lives); // üíö PARPADEA EL CORAZ√ìN PERDIDO

roach2.active = false;
roach2Hit = true; // üö´ evita que reaparezca en la misma vida
}
}

function updateRoachDuel() {
if (!roachTop.active && !roachBottom.active) return;

// mover
if (roachTop.active) roachTop.row += 0.04;     // baja
if (roachBottom.active) roachBottom.row -= 0.04; // sube

// üí• choque entre ellas
if (
roachTop.active &&
roachBottom.active &&
!roachDuelFinished &&
Math.abs(roachTop.row - roachBottom.row) < 0.5
) {
roachTop.active = false;
roachBottom.active = false;
roachTop.hit = true;
roachBottom.hit = true;
roachDuelFinished = true;

spawnDamageParticles(
PADDING_X + 50 * CELL,
PADDING_Y + 17 * CELL
);

return;

}

// üíö colisiones con el sapito
checkRoachHit(roachTop);
checkRoachHit(roachBottom);
}

function updateRoachPatrol() {
if (!roachPatrol.active || roachPatrol.finished) return;

// mover
roachPatrol.col += 0.05 * roachPatrol.dir;

// cambiar direcci√≥n en los l√≠mites
if (roachPatrol.col <= patrolLeftLimit) {
roachPatrol.col = patrolLeftLimit;
roachPatrol.dir = 1;
}

if (roachPatrol.col >= patrolRightLimit) {
roachPatrol.col = patrolRightLimit;
roachPatrol.dir = -1;
}

// üíö colisi√≥n con el sapito
if (
Math.round(roachPatrol.row) === player.row &&
Math.round(roachPatrol.col) === player.col &&
!roachPatrol.hit
) {
roachPatrol.hit = true;
roachPatrol.active = false;
roachPatrol.finished = true;

lives--;
blinkHeart(lives);
spawnDamageParticles(player.x, player.y);
checkGameOver();

lockMessageSound();

setMessage("¬°La cucaracha patrulla te atrap√≥! üíö", {
vibratePattern: [80,40,80],
sound: false   // üîï NO notificaci√≥n
});

soundEat.currentTime = 0;
soundEat.play().catch(()=>{});

}
}

function updateRoachDrop() {
if (!roachDrop.active || roachDrop.finished) return;

// bajar
if (roachDrop.row < roachDropEndRow) {
roachDrop.row += 0.04; // velocidad de ca√≠da
} else {
roachDrop.active = false;
roachDrop.finished = true;
return;
}

// üíö colisi√≥n con sapito
if (
Math.round(roachDrop.row) === player.row &&
roachDrop.col === player.col &&
!roachDrop.hit
) {
roachDrop.hit = true;
roachDrop.active = false;
roachDrop.finished = true;

lives--;
blinkHeart(lives);
spawnDamageParticles(player.x, player.y);
checkGameOver();

lockMessageSound();

setMessage("te mordi√≥ una cucaracha", {
vibratePattern: [80,40,80],
sound: false
});

soundEat.currentTime = 0;
soundEat.play().catch(()=>{});

}
}

function checkRoachHit(roachObj) {
if (!roachObj.active || roachObj.hit) return;

const sameColumn = Math.abs(roachObj.col - player.col) < 0.5;
const sameRow = Math.abs(roachObj.row - player.row) < 0.5;

if (sameRow && sameColumn) {
roachObj.hit = true;
roachObj.active = false;

lives--;
blinkHeart(lives);
spawnDamageParticles(player.x, player.y);
checkGameOver();

lockMessageSound();

setMessage("te mordi√≥ una cucaracha", {
vibratePattern: [80,40,80],
sound: false   // üîï NO notificaci√≥n
});

soundEat.currentTime = 0;
soundEat.play().catch(()=>{});

}
}

function drawMessage() {
const scale = 1.5;
const lineSpacing = 10 * scale;

const maxWidth = LABYRINTH_WIDTH;
const lines = wrapPixelText(currentMessage, maxWidth, scale);

let y =
TITLE_HEIGHT / 2 +
TITLE_OFFSET_Y +
MESSAGE_OFFSET_Y -
(lines.length - 1) * lineSpacing / 2;

ctx.save();                 // üëà
ctx.globalAlpha = messageAlpha; // üëà

for (let line of lines) {
const lineWidth = getPixelTextWidth(line, scale);
const x = PADDING_X + (LABYRINTH_WIDTH - lineWidth) / 2;

drawPixelText(line, x, y, scale, "#3cff3c");
y += lineSpacing;

}

ctx.restore(); // üëà
}

function isSpecialZone(row, col) {
return (
(row === 17 && col === 50) || // controles invertidos
(row === 42 && col === 34)    // volver a la normalidad
);
}

function drawPixelHeart(x, y, scale, filled) {
const pixels = [
[0,1,1,0,1,1,0],
[1,1,1,1,1,1,1],
[1,1,1,1,1,1,1],
[0,1,1,1,1,1,0],
[0,0,1,1,1,0,0],
[0,0,0,1,0,0,0],
];

const colorFull = "#3cff3c";   // üíö verde brillante
const colorEmpty = "#1b4d1b";  // üíö verde oscuro (vac√≠o)

ctx.fillStyle = filled ? colorFull : colorEmpty;

for (let row = 0; row < pixels.length; row++) {
for (let col = 0; col < pixels[row].length; col++) {
if (pixels[row][col]) {
ctx.fillRect(
x + col * scale,
y + row * scale,
scale,
scale
);
}
}
}
}

const pixelFont = {
A:["0110","1001","1111","1001","1001"],
B:["1110","1001","1110","1001","1110"],
C:["0111","1000","1000","1000","0111"],
D:["1110","1001","1001","1001","1110"],
E:["1111","1000","1110","1000","1111"],
F:["1111","1000","1110","1000","1000"],
G:["0111","1000","1011","1001","0111"],
H:["1001","1001","1111","1001","1001"],
I:["111","010","010","010","111"],
J:["0011","0001","0001","1001","0110"],
K:["1001","1010","1100","1010","1001"],
L:["1000","1000","1000","1000","1111"],
M:["10001","11011","10101","10001","10001"],
N:["1001","1101","1011","1001","1001"],
O:["0110","1001","1001","1001","0110"],
P:["1110","1001","1110","1000","1000"],
Q:["0110","1001","1001","1010","0101"],
R:["1110","1001","1110","1010","1001"],
S:["0111","1000","0110","0001","1110"],
T:["1111","0010","0010","0010","0010"],
U:["1001","1001","1001","1001","0110"],
V:["1001","1001","1001","0101","0010"],
W:["10001","10001","10101","11011","10001"],
X:["1001","0101","0010","0101","1001"],
Y:["1001","0101","0010","0010","0010"],
Z:["1111","0001","0010","0100","1111"],

// n√∫meros
"0":["0110","1001","1001","1001","0110"],
"1":["010","110","010","010","111"],
"2":["1110","0001","0110","1000","1111"],
"3":["1110","0001","0110","0001","1110"],
"4":["1001","1001","1111","0001","0001"],
"5":["1111","1000","1110","0001","1110"],
"6":["0111","1000","1110","1001","0110"],
"7":["1111","0001","0010","0100","0100"],
"8":["0110","1001","0110","1001","0110"],
"9":["0110","1001","0111","0001","1110"],

// signos
"!":["1","1","1","0","1"],
"?":["111","001","011","000","010"],
".":["0","0","0","0","1"],
",":["0","0","0","1","1"],
":":["0","1","0","1","0"],
"‚Ä¶":["0","0","0","0","0"],

" ":["0","0","0","0","0"]
};

function drawPixelText(text, x, y, scale = 2, color = "#3cff3c") {
text = text
.toUpperCase()
.normalize("NFD")
.replace(/[\u0300-\u036f]/g, "");
let cursorX = x;

ctx.fillStyle = color;

for (let char of text) {
const glyph = pixelFont[char] || pixelFont[" "];

for (let row = 0; row < glyph.length; row++) {
for (let col = 0; col < glyph[row].length; col++) {
if (glyph[row][col] === "1") {
ctx.fillRect(
cursorX + col * scale,
y + row * scale,
scale,
scale
);
}
}
}

cursorX += (glyph[0].length + 1) * scale;

}
}

function getPixelTextWidth(text, scale) {
text = text.toUpperCase();
let width = 0;

for (let char of text) {
const glyph = pixelFont[char] || pixelFont[" "];
width += (glyph[0].length + 1) * scale;
}

return width;
}

function getCenteredMazeX(text, scale) {
const width = getPixelTextWidth(text, scale);
return MAZE_CENTER_X - width / 2;
}

function spawnDamageParticles(x, y, amount = 12) {
for (let i = 0; i < amount; i++) {
damageParticles.push({
x,
y,
vx: (Math.random() - 0.5) * 3,
vy: (Math.random() - 0.5) * 3,
life: 30,
size: Math.random() * 3 + 2
});
}
}

function spawnFlowerParticles(x, y) {
for (let i = 0; i < 8; i++) {
damageParticles.push({
x,
y,
vx: (Math.random() - 0.5) * 2,
vy: (Math.random() - 0.5) * 2,
life: 25,
size: 2,
color: "#ff9fe5"
});
}
}

function blinkHeart(index) {
blinkingHeartIndex = index;
heartBlinkCount = 0;

if (heartBlinkInterval) {
clearInterval(heartBlinkInterval);
}

heartBlinkInterval = setInterval(() => {
heartBlinkCount++;

if (heartBlinkCount >= 6) { // 3 parpadeos
clearInterval(heartBlinkInterval);
blinkingHeartIndex = -1;
}

}, 150);
}

function wrapPixelText(text, maxWidth, scale) {
const words = text.split(" ");
const lines = [];
let currentLine = "";

for (let word of words) {
const testLine = currentLine ? currentLine + " " + word : word;
const testWidth = getPixelTextWidth(testLine, scale);

if (testWidth > maxWidth && currentLine) {
lines.push(currentLine);
currentLine = word;
} else {
currentLine = testLine;
}

}

if (currentLine) lines.push(currentLine);

return lines;
}

function updateAndDrawParticles() {
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];

p.x += p.vx;
p.y += p.vy;
p.life--;

ctx.fillStyle = `rgba(60, 255, 60, ${p.life / 20})`;
ctx.fillRect(p.x, p.y, 2, 2);

if (p.life <= 0) {
particles.splice(i, 1);
}

}
}

function drawDamageParticles() {
for (let i = damageParticles.length - 1; i >= 0; i--) {
const p = damageParticles[i];

p.x += p.vx;
p.y += p.vy;
p.life--;

ctx.globalAlpha = p.life / 30;
ctx.fillStyle = "#ff3c3c"; // rojo intenso üí•
ctx.fillRect(p.x, p.y, p.size, p.size);
ctx.globalAlpha = 1;

if (p.life <= 0) {
damageParticles.splice(i, 1);
}

}
}

function drawFlowers() {
for (let i = flowers.length - 1; i >= 0; i--) {
const f = flowers[i];

if (f.state === "grow") {
f.size += 0.08;
if (f.size >= f.maxSize) {
f.state = "idle";
}
}

if (f.state === "idle") {
f.life--;
if (f.life <= 0) {
spawnFlowerParticles(f.x, f.y);
flowers.splice(i, 1);
continue;
}
}

const s = f.size;

ctx.fillStyle = "#ff7ac8"; // p√©talos
ctx.fillRect(f.x - s,     f.y,       s, s);
ctx.fillRect(f.x + s,     f.y,       s, s);
ctx.fillRect(f.x,         f.y - s,   s, s);
ctx.fillRect(f.x,         f.y + s,   s, s);

ctx.fillStyle = "#ffe066"; // centro
ctx.fillRect(f.x, f.y, s, s);
}
}

function drawLives() {
if (!finalBlinkVisible && finalBlinking) return;
const heartScale = 2;
const spacing = 18;

// üìç Esquina inferior izquierda DEL LABERINTO
const xStart = PADDING_X;
const yStart = PADDING_Y + ROWS * CELL + 8;

for (let i = 0; i < MAX_LIVES; i++) {
let filled = i < lives;

// üíö parpadeo del coraz√≥n perdido
if (i === blinkingHeartIndex) {
filled = heartBlinkCount % 2 === 0;
}

drawPixelHeart(
xStart + i * spacing,
yStart,
heartScale,
filled
);
}
}

function updateMessageByPosition() {
for (let m of messagesByZone) {
if (
player.row === m.row &&
player.col === m.col &&
!isSpecialZone(player.row, player.col)
) {

// üö´ No volver a mostrar el mensaje de la cucaracha si ya fue comida
if (
m.row === 5 &&
m.col === 4 &&
roachEaten
) {
continue;
}
if (currentMessage !== m.text) {
currentMessage = m.text;

blinkMessage(); // ‚ú® PARPADEO DEL TEXTO

vibrate(40);

if (!roachEating && !messageSoundLocked) {
soundMessage.currentTime = 0;
soundMessage.play().catch(() => {});
}
}

// ü™≥ Activar misi√≥n de la cucaracha
if (m.row === 5 && m.col === 4 && !roachEaten) {
roachActive = true;
blockActive = true;
vibrate([60, 80, 60]);
}

break;
}

}
}

function updateSpecialZones() {

// üîÑ Invertir controles
if (player.row === 17 && player.col === 50 && !controlsInverted) {
controlsInverted = true;
setMessage("severla √°tse odot‚Ä¶ etartn√©cnoc", {
vibratePattern: [60, 40, 60, 40]
});
}

// ‚úÖ Volver a controles normales
if (player.row === 42 && player.col === 34 && controlsInverted) {
controlsInverted = false;
setMessage("volvieron a la normalidad los controles", {
vibratePattern: [80, 40, 80]
});
}

// üëª Apagar laberinto
if (player.row === 10 && player.col === 38) {
if (!mazeBlinking && mazeVisible) {
setMessage("Avanza siempre aunque no veas el camino", {
vibratePattern: 60
});
vibrate([80, 40, 80]);
blinkMaze(8, 120);
blinkSigns(8, 120);
}
}

// ü™≥ Activar cucaracha patrulla
if (
player.row === 28 &&
player.col === 46 &&
!roachPatrol.active &&
!roachPatrol.finished
) {
roachPatrol.active = true;

setMessage("Escuchas patitas corriendo‚Ä¶ ü™≥", {
vibratePattern: [60,40,60]
});
}

// ü™≥ Activar cucaracha que cae del techo
if (
player.row === 41 &&
player.col === 34 &&
!roachDrop.active &&
!roachDrop.finished
) {
roachDrop.active = true;
roachDrop.row = roachDropStartRow;

setMessage("Escuchas algo caer‚Ä¶ ü™≥", {
vibratePattern: [60,40,60]
});
}

// üõë Desactivar si llegas a zona segura
if (player.row === 35 && player.col === 38 && roachPatrol.active) {
roachPatrol.active = false;
roachPatrol.finished = true;
}

// ‚ú® Volver a mostrar el laberinto
if (player.row === 24 && player.col === 38 && !mazeVisible) {
mazeVisible = true;
signsVisible = true;

setMessage("¬°lo lograste! siempre encontrar√°s el camino devuelta", {
vibratePattern: 60
});
}

// ü™≥ Activar cucaracha vengadora
if (
player.row === 2 &&
player.col === 28 &&
!roach2.active &&
!roach2Hit
) {
roach2.active = true;

setMessage("¬°Cuidado! ü™≥ La cucaracha vengadora aparece", {
vibratePattern: [60, 40, 60]
});
}

// ü™≥ü™≥ Activar duelo de cucarachas
if (
player.row === 17 &&
player.col === 50 &&
!roachDuelTriggered
) {
roachDuelTriggered = true; // üîí bloquear para siempre

roachTop.row = 8;
roachBottom.row = 26;

roachTop.hit = false;
roachBottom.hit = false;

roachTop.active = true;
roachBottom.active = true;

setMessage("cuidado, los controles est√°n invertidos", {
vibratePattern: [60, 40, 60, 40]
});
}
}

function checkCheckpoint() {
  for (let s of signPosts) {
    if (player.row === s.row && player.col === s.col) {

      // si ya es el mismo checkpoint no repetir
      if (lastCheckpoint &&
          lastCheckpoint.row === s.row &&
          lastCheckpoint.col === s.col) return;

      lastCheckpoint = { row: s.row, col: s.col };

      setMessage(" Punto de control alcanzado", {
        vibratePattern: [40, 40],
      });

      break;
    }
  }
}

function checkRoachEatCollision() {
if (
roachActive &&
!roachEaten &&
!roachEating &&
player.row === roach.row &&
player.col === roach.col
) {
roachEating = true;
blockActive = false;

setMessage("Mmm... sabe a pica pollo", {
sound: false,
vibratePattern: null
});

vibrationUnlocked = true;
vibrate([40, 60, 40, 60]);

soundEat.currentTime = 0;
soundEat.play().catch(() => {});

}
}

function updatePlayerPixels() {
player.x = PADDING_X + player.col * CELL + CELL / 2;
player.y = PADDING_Y + player.row * CELL + CELL / 2;
player.targetX = player.x;
player.targetY = player.y;
}

updatePlayerPixels();
player.moving = true;

const roachImg = new Image();
roachImg.src = "cucaracha.png";
let roachReady = false;
let roachBreath = 0;

roachImg.onload = () => roachReady = true;

// Imagen del sapito
const playerImg = new Image();
playerImg.src = "sapito.png";
// Imagen de la princesa (salida)
const princessImg = new Image();
princessImg.src = "princesa.png";
const signImg = new Image();
signImg.src = "cartel.png"; // tu imagen del cartel de madera
let signReady = false;

signImg.onload = () => signReady = true;

// Sonidos
const bgMusic = new Audio("musica.ogg"); // cambia el nombre por tu archivo real
bgMusic.loop = true;     // üîÅ que se repita sola
bgMusic.volume = 0.2;   // üîâ volumen suave de fondo
const soundMove = new Audio("tap.mp3");
const soundBlock = new Audio("block.wav");
const soundWin = new Audio("win.wav");
const soundEat = new Audio("eat.mp3");
soundEat.volume = 0.3;
const soundPrincessGone = new Audio("princess_gone.mp3");
soundPrincessGone.volume = 0.3;

const soundEndingStart = new Audio("ending_start.mp3");
soundEndingStart.volume = 0.6;

const soundMessage = new Audio("notificacion.mp3");
soundMessage.volume = 0.3;

// Vol√∫menes (aj√∫stalos a gusto)
soundMove.volume = 0.25;
soundBlock.volume = 0.01;
soundWin.volume = 0.2;

let playerReady = false;
let princessReady = false;

// Dibujar laberinto
function drawMaze() {
if (!mazeVisible) return; // üëª laberinto invisible
ctx.strokeStyle = "#0af"; // color de las l√≠neas
ctx.lineWidth = 1;
ctx.lineCap = "round";
ctx.lineJoin = "round";

ctx.beginPath();

for (let r = 0; r < ROWS; r++) {
for (let c = 0; c < COLS; c++) {
if (maze[r][c] === 1) {

const x = PADDING_X + c * CELL;
const y = PADDING_Y + r * CELL;

// arriba
if (maze[r - 1]?.[c] !== 1) {
ctx.moveTo(x, y);
ctx.lineTo(x + CELL, y);
}

// abajo
if (maze[r + 1]?.[c] !== 1) {
ctx.moveTo(x, y + CELL);
ctx.lineTo(x + CELL, y + CELL);
}

// izquierda
if (maze[r]?.[c - 1] !== 1) {
ctx.moveTo(x, y);
ctx.lineTo(x, y + CELL);
}

// derecha
if (maze[r]?.[c + 1] !== 1) {
ctx.moveTo(x + CELL, y);
ctx.lineTo(x + CELL, y + CELL);
}

}
}

}

ctx.stroke();
}

function setMessage(
text,
{
blink = true,
vibratePattern = 40,
sound = true
} = {}
) {
if (currentMessage === text) return;

currentMessage = text;

if (blink) blinkMessage();
if (vibratePattern) vibrate(vibratePattern);

// üîí BLOQUEO GLOBAL DE SONIDOS DE MENSAJE
if (sound && !roachEating && !messageSoundLocked) {
soundMessage.currentTime = 0;
soundMessage.play().catch(() => {});
}
}

function blinkMessage(times = 4, speed = 120) {
if (messageBlinking) return;

messageBlinking = true;
messageBlinkCount = 0;

if (messageBlinkInterval) {
clearInterval(messageBlinkInterval);
}

messageBlinkInterval = setInterval(() => {
messageAlpha = messageAlpha === 1 ? 0.2 : 1;
messageBlinkCount++;

if (messageBlinkCount >= times) {
clearInterval(messageBlinkInterval);
messageAlpha = 1;
messageBlinking = false;
}

}, speed);
}

function blinkMaze(times = 6, speed = 150) {
if (mazeBlinking) return;

mazeBlinking = true;
let count = 0;

mazeBlinkInterval = setInterval(() => {
mazeVisible = !mazeVisible;
count++;

if (count >= times) {
clearInterval(mazeBlinkInterval);
mazeVisible = false; // üëª queda invisible
mazeBlinking = false;
}

}, speed);
}

function blinkFinalScene(times = 8, speed = 120) {
if (finalBlinking) return;

finalBlinking = true;
let count = 0;

finalBlinkInterval = setInterval(() => {
finalBlinkVisible = !finalBlinkVisible;
mazeVisible = finalBlinkVisible; // laberinto
count++;

if (count >= times) {
clearInterval(finalBlinkInterval);
finalBlinking = false;
mazeVisible = false;
finalBlinkVisible = false;
}

}, speed);
}

function blinkSigns(times = 6, speed = 120) {

if (signsBlinkInterval) clearInterval(signsBlinkInterval);

signsBlinking = true;
let count = 0;

signsBlinkInterval = setInterval(() => {

signsVisible = !signsVisible;
count++;

if (count >= times) {
clearInterval(signsBlinkInterval);
signsBlinking = false;
signsVisible = false; // quedan ocultos
}

}, speed);
}

// Dibujar jugador con imagen centrada
function drawPlayer() {
if (!finalBlinkVisible && finalBlinking) return;
const size = CELL * 3;

// ctx.fillStyle = "#fff";
// ctx.font = "12px monospace";
// ctx.fillText(
// `(${player.row}, ${player.col})`,
// player.x + 12,
// player.y - 12
// );

ctx.drawImage(
playerImg,
player.x - size / 2,
player.y - size / 2,
size,
size
);
}

function spawnParticles(x, y) {
for (let i = 0; i < 6; i++) {
particles.push({
x: x + (Math.random() * 6 - 3),
y: y + (Math.random() * 6 - 3),
vx: Math.random() * 0.8 - 0.4,
vy: Math.random() * 0.8 - 0.4,
life: 20
});
}
}

function spawnFlower(x, y) {
flowers.push({
x,
y,
size: 0.2,
maxSize: 2.5,
life: 90,
state: "grow"
});
}

function canSpawnFlower(x, y) {
for (let f of flowers) {
const dx = f.x - x;
const dy = f.y - y;
const dist = Math.sqrt(dx * dx + dy * dy);

if (dist < FLOWER_MIN_DISTANCE) {
return false; // muy cerca de otra flor
}

}
return true;
}

function animate() {
ctx.clearRect(0, 0, canvas.width, canvas.height);

// üé¨ SI EST√Å ACTIVA LA ESCENA FINAL, SOLO DIBUJAR ESO
if (endingActive) {
drawEndingScene();
requestAnimationFrame(animate);
return;
}

checkSpecialPrincessZone();

if (roachReady) drawRoach();
updateRoach2();
drawRoach2();

updateRoachDuel();
drawRoachDuel();

updateRoachPatrol();
drawRoachPatrol();
updateRoachDrop();
drawRoachDrop();
drawMessage();
drawMaze();
drawSignPosts(); // ü™ß dibujar carteles
if (princessReady) drawPrincess();

updateAndDrawParticles();
drawFlowers();

if (playerReady) drawPlayer();

drawDamageParticles();

drawLives(); // üíö SIEMPRE AL FINAL (encima de todo)

drawGameOver();

if (player.moving) {
const speed = 0.2; // velocidad suave, menor que 1

// interpolaci√≥n lineal suavizada
player.x += (player.targetX - player.x) * speed;
player.y += (player.targetY - player.y) * speed;

// si estamos muy cerca, fijar posici√≥n exacta
if (Math.abs(player.x - player.targetX) < 0.5 &&
Math.abs(player.y - player.targetY) < 0.5) {
player.x = player.targetX;
player.y = player.targetY;
player.moving = false;
}
}

checkRoachEatCollision();

requestAnimationFrame(animate);
}

// Movimiento
function movePlayer(dr, dc) {
if (player.moving) return;
if (gameOver) return;

// üîí BLOQUEO TOTAL durante la escena especial
if (specialSceneActive) return;

// bloqueo especial
if (
blockActive &&
player.row === 5 &&
player.col === 4 &&
dr === 0 && dc === 1
) {
soundBlock.currentTime = 0;
soundBlock.play();
return;
}

const newRow = player.row + dr;
const newCol = player.col + dc;

if (maze[newRow][newCol] === 0) {
player.row = newRow;
player.col = newCol;

// üå∏ Pasillo de flores (solo izquierda ‚ûú derecha)
if (
player.row === flowerZone.row &&
dc === 1 &&
player.col >= flowerZone.colStart &&
player.col <= flowerZone.colEnd
) {
const fx = PADDING_X + player.col * CELL + CELL / 2;
const fy = PADDING_Y + player.row * CELL + CELL / 2;

if (canSpawnFlower(fx, fy)) {
spawnFlower(fx, fy);
}
}

spawnParticles(player.x, player.y + CELL / 2);

updateMessageByPosition();
updateSpecialZones();
checkCheckpoint();

player.targetX = PADDING_X + newCol * CELL + CELL / 2;
player.targetY = PADDING_Y + newRow * CELL + CELL / 2;

player.moving = true;

soundMove.currentTime = 0;

soundMove.play();
}
}

function moveWithControls(dr, dc) {
if (controlsInverted) {
movePlayer(-dr, -dc);
} else {
movePlayer(dr, dc);
}
}

// Botones
// Botones
document.querySelector(".up").addEventListener("click", e => {
  e.preventDefault();
  vibrationUnlocked = true;
  startMusic();
  moveWithControls(-1, 0);
});

document.querySelector(".down").addEventListener("click", e => {
  e.preventDefault();
  vibrationUnlocked = true;
  startMusic();
  moveWithControls(1, 0);
});

document.querySelector(".left").addEventListener("click", e => {
  e.preventDefault();
  vibrationUnlocked = true;
  startMusic();
  moveWithControls(0, -1);
});

document.querySelector(".right").addEventListener("click", e => {
  e.preventDefault();
  vibrationUnlocked = true;
  startMusic();
  moveWithControls(0, 1);
});

// Teclado
document.addEventListener("keydown", e => {
startMusic();

if(e.key === "ArrowUp") moveWithControls(-1,0);
if(e.key === "ArrowDown") moveWithControls(1,0);
if(e.key === "ArrowLeft") moveWithControls(0,-1);
if(e.key === "ArrowRight") moveWithControls(0,1);
});

// Inicializar
playerImg.onload = () => {
playerReady = true;
updatePlayerPixels();
animate();
};

princessImg.onload = () => {
princessReady = true;
};

princessImg.onerror = () => {
alert("‚ùå No se pudo cargar princesa.png");
};

playerImg.onerror = () => {
alert("‚ùå No se pudo cargar sapito.png");
};

</script>  </body>

</html>